// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CLI Should generate accesso api: code 1`] = `
"// Accesso App Public API. 0.3.0
// ---
// This file is automatically generated by swagger-to-js with preset @sergeysova/swagger-to-js-preset
// Do not edit this file directly. Instead open swagger-to-js config file and follow the link in \\"file\\"
import { createEffect } from 'effector-root';
import * as typed from 'typed-contracts';
import { requestFx } from './request';

//#region prebuilt code
const custom = { any: (valueName: string, value: unknown): any => value }

export type GenericErrors =
  | {
      status: 'unexpected';
      error: Error;
    }
  | {
      status: 'unknown_status';
      error: { status: number; body: unknown };
    }
  | {
      status: 'validation_error';
      error: typed.ValidationError;
    };

function parseWith<T>(
  name: string,
  contract: typed.Contract<T>,
  value: unknown,
): T {
  const parsed = contract(name, value);
  if (parsed instanceof typed.ValidationError) {
    throw { status: 'validation_error', error: parsed };
  }
  return parsed;
}

function throwWith<T>(
  name: string,
  contract: typed.Contract<T>,
  status: string,
  value: unknown,
) {
  const error = parseWith(name, contract, value);
  throw { status, error };
}

interface AccessRecoverySendEmail {
  email: string;
}
//#endregion prebuilt code//#region oauthAuthorizeRequest
const oauthAuthorizeRequestOk = typed.object({
  // User should be redirected to
  redirectUri: type.string,
  // This parameter contains the authorization code which the client will later exchange for an access token.
  code: type.string,
  // If the initial request contained a state parameter, the response must also include the exact value from the request. The client will be using this to associate this response with the initial request.
  state: type.string.maybe,
});
const oauthAuthorizeRequestDone = typed.union(oauthAuthorizeRequestOk)
export type OauthAuthorizeRequestDone =
  | {
      status: 'ok';
      // Authorization completed, now access token can be obtained.
      answer: typed.Get<typeof oauthAuthorizeRequestOk>;
    }
  | GenericErrors;
// Authorization request
export const oauthAuthorizeRequestFx = createEffect<OauthAuthorizeRequest, OauthAuthorizeRequestDone, OauthAuthorizeRequestFail>({
  async handler() {
    const name = 'oauthAuthorizeRequest.body'
    const answer = await requestFx({
      path: '/oauth/authorize',
      method: 'POST',
    })
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, oauthAuthorizeRequestOk, answer.body),
        };
      case 400:
        return {
          status: 'bad_request',
          answer: parseWith(name, oauthAuthorizeRequestBadRequest, answer.body),
        };
      case 500:
        throwWith(
          name,
          oauthAuthorizeRequestInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion oauthAuthorizeRequest

//#region oauthToken
const oauthTokenCreated = typed.object({
  access_token: type.string,
  token_type: type.union('bearer'),
  // UTC Unix TimeStamp when the access token expires
  expires_in: custom.any.maybe,
});
const oauthTokenDone = typed.union(oauthTokenCreated)
export type OauthTokenDone =
  | {
      status: 'created';
      // The auth services validated the request and responds with an access token [OAuth2 Example Flow](https://www.oauth.com/oauth2-servers/server-side-apps/example-flow/)
      answer: typed.Get<typeof oauthTokenCreated>;
    }
  | GenericErrors;
// Exchange the authorization code for an access token
export const oauthTokenFx = createEffect<OauthToken, OauthTokenDone, OauthTokenFail>({
  async handler() {
    const name = 'oauthToken.body'
    const answer = await requestFx({
      path: '/oauth/token',
      method: 'POST',
    })
    switch (answer.status) {
      case 201:
        return {
          status: 'created',
          answer: parseWith(name, oauthTokenCreated, answer.body),
        };
      case 400:
        return {
          status: 'bad_request',
          answer: parseWith(name, oauthTokenBadRequest, answer.body),
        };
      case 500:
        throwWith(
          name,
          oauthTokenInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion oauthToken

//#region accessRecoverySendEmail
const accessRecoverySendEmailOk = typed.undef;
const accessRecoverySendEmailDone = typed.union(accessRecoverySendEmailOk)
export type AccessRecoverySendEmailDone =
  | {
      status: 'ok';
      // Password changed successfully
      answer: typed.Get<typeof accessRecoverySendEmailOk>;
    }
  | GenericErrors;
// Send password recovery confirmation code to email
export const accessRecoverySendEmailFx = createEffect<AccessRecoverySendEmail, AccessRecoverySendEmailDone, AccessRecoverySendEmailFail>({
  async handler() {
    const name = 'accessRecoverySendEmail.body'
    const answer = await requestFx({
      path: '/access-recovery/send-email',
      method: 'POST',
    })
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, accessRecoverySendEmailOk, answer.body),
        };
      case 400:
        return {
          status: 'bad_request',
          answer: parseWith(name, accessRecoverySendEmailBadRequest, answer.body),
        };
      case 500:
        throwWith(
          name,
          accessRecoverySendEmailInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion accessRecoverySendEmail

//#region accessRecoverySetPassword
const accessRecoverySetPasswordOk = typed.undef;
const accessRecoverySetPasswordDone = typed.union(accessRecoverySetPasswordOk)
export type AccessRecoverySetPasswordDone =
  | {
      status: 'ok';
      // Confirmation code is sent to email
      answer: typed.Get<typeof accessRecoverySetPasswordOk>;
    }
  | GenericErrors;
// Set new password by reset code from email
export const accessRecoverySetPasswordFx = createEffect<AccessRecoverySetPassword, AccessRecoverySetPasswordDone, AccessRecoverySetPasswordFail>({
  async handler() {
    const name = 'accessRecoverySetPassword.body'
    const answer = await requestFx({
      path: '/access-recovery/set-password',
      method: 'POST',
    })
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, accessRecoverySetPasswordOk, answer.body),
        };
      case 400:
        return {
          status: 'bad_request',
          answer: parseWith(name, accessRecoverySetPasswordBadRequest, answer.body),
        };
      case 500:
        throwWith(
          name,
          accessRecoverySetPasswordInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion accessRecoverySetPassword

//#region viewerGet
const viewerGetOk = typed.object({
  firstName: type.string,
  lastName: type.string,
  id: type.string,
});
const viewerGetDone = typed.union(viewerGetOk)
export type ViewerGetDone =
  | {
      status: 'ok';
      // Get profile of the user
      answer: typed.Get<typeof viewerGetOk>;
    }
  | GenericErrors;
// Get info about viewer by access token
export const viewerGetFx = createEffect<ViewerGet, ViewerGetDone, ViewerGetFail>({
  async handler() {
    const name = 'viewerGet.body'
    const answer = await requestFx({
      path: '/viewer',
      method: 'GET',
    })
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, viewerGetOk, answer.body),
        };
      case 400:
        return {
          status: 'bad_request',
          answer: parseWith(name, viewerGetBadRequest, answer.body),
        };
      case 500:
        throwWith(
          name,
          viewerGetInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion viewerGet

//#region registerRequest
const registerRequestCreated = typed.object({
  // UTC Unix TimeStamp when the link expires
  expiresAt: custom.any,
});
const registerRequestDone = typed.union(registerRequestCreated)
export type RegisterRequestDone =
  | {
      status: 'created';
      // Registration link sent to email, now user can find out when the link expires
      answer: typed.Get<typeof registerRequestCreated>;
    }
  | GenericErrors;
// Send registration link to email
export const registerRequestFx = createEffect<RegisterRequest, RegisterRequestDone, RegisterRequestFail>({
  async handler() {
    const name = 'registerRequest.body'
    const answer = await requestFx({
      path: '/register/request',
      method: 'POST',
    })
    switch (answer.status) {
      case 201:
        return {
          status: 'created',
          answer: parseWith(name, registerRequestCreated, answer.body),
        };
      case 400:
        return {
          status: 'bad_request',
          answer: parseWith(name, registerRequestBadRequest, answer.body),
        };
      case 500:
        throwWith(
          name,
          registerRequestInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion registerRequest

//#region registerConfirmation
const registerConfirmationCreated = typed.undef;
const registerConfirmationDone = typed.union(registerConfirmationCreated)
export type RegisterConfirmationDone =
  | {
      status: 'created';
      // Okay, user created
      answer: typed.Get<typeof registerConfirmationCreated>;
    }
  | GenericErrors;
// Confirm email, fill profile required fields and create user
export const registerConfirmationFx = createEffect<RegisterConfirmation, RegisterConfirmationDone, RegisterConfirmationFail>({
  async handler() {
    const name = 'registerConfirmation.body'
    const answer = await requestFx({
      path: '/register/confirmation',
      method: 'POST',
    })
    switch (answer.status) {
      case 201:
        return {
          status: 'created',
          answer: parseWith(name, registerConfirmationCreated, answer.body),
        };
      case 400:
        return {
          status: 'bad_request',
          answer: parseWith(name, registerConfirmationBadRequest, answer.body),
        };
      case 500:
        throwWith(
          name,
          registerConfirmationInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion registerConfirmation

//#region sessionCreate
const sessionCreateCreated = typed.object({
  firstName: type.string,
  lastName: type.string,
});
const sessionCreateDone = typed.union(sessionCreateCreated)
export type SessionCreateDone =
  | {
      status: 'created';
      // Session created, token wrote to cookies
      answer: typed.Get<typeof sessionCreateCreated>;
    }
  | GenericErrors;
// Login and create new session token
export const sessionCreateFx = createEffect<SessionCreate, SessionCreateDone, SessionCreateFail>({
  async handler() {
    const name = 'sessionCreate.body'
    const answer = await requestFx({
      path: '/session/create',
      method: 'POST',
    })
    switch (answer.status) {
      case 201:
        return {
          status: 'created',
          answer: parseWith(name, sessionCreateCreated, answer.body),
        };
      case 400:
        return {
          status: 'bad_request',
          answer: parseWith(name, sessionCreateBadRequest, answer.body),
        };
      case 500:
        throwWith(
          name,
          sessionCreateInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion sessionCreate

//#region sessionGet
const sessionGetOk = typed.object({
  // Current user in a session
  user: typed.object({
      firstName: type.string,
      lastName: type.string,
  }),
});
const sessionGetDone = typed.union(sessionGetOk)
export type SessionGetDone =
  | {
      status: 'ok';
      // Session exists
      answer: typed.Get<typeof sessionGetOk>;
    }
  | GenericErrors;
// Read session token and show current session. Authenticated checked by session-token cookie
export const sessionGetFx = createEffect<SessionGet, SessionGetDone, SessionGetFail>({
  async handler() {
    const name = 'sessionGet.body'
    const answer = await requestFx({
      path: '/session/get',
      method: 'POST',
    })
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, sessionGetOk, answer.body),
        };
      case 401:
        throwWith(
          name,
          sessionGetUnauthorized,
          'unauthorized',
          answer.body,
        );
      case 500:
        throwWith(
          name,
          sessionGetInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  }
})
//#endregion sessionGet

"
`;

exports[`CLI Should generate accesso api: files 1`] = `
"accesso-app-public-api.ts
"
`;
