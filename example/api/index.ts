// Accesso App Public API. 0.3.0
// ---
// This file is automatically generated by swagger-to-js with preset @sergeysova/swagger-to-js-preset
// Do not edit this file directly. Instead open swagger-to-js config file and follow the link in "file"
import { createEffect } from 'effector';
import * as typed from 'typed-contracts';
import { requestFx } from './request';

//#region prebuilt code
const custom = { any: (valueName: string, value: unknown): any => value };

export type GenericErrors =
  | {
      status: 'unexpected';
      error: Error;
    }
  | {
      status: 'unknown_status';
      error: { status: number; body: unknown };
    }
  | {
      status: 'validation_error';
      error: typed.ValidationError;
    };

function parseWith<T>(
  name: string,
  contract: typed.Contract<T>,
  value: unknown,
): T {
  const parsed = contract(name, value);
  if (parsed instanceof typed.ValidationError) {
    throw { status: 'validation_error', error: parsed };
  }
  return parsed;
}

function throwWith<T>(
  name: string,
  contract: typed.Contract<T>,
  status: string,
  value: unknown,
) {
  const error = parseWith(name, contract, value);
  throw { status, error };
}

interface AccessRecoverySendEmail {
  email: string;
}
//#endregion prebuilt code//#region oauthAuthorizeRequest
const oauthAuthorizeRequestOk = typed.object({
  // User should be redirected to
  redirectUri: typed.string,
  // This parameter contains the authorization code which the client will later exchange for an access token.
  code: typed.string,
  // If the initial request contained a state parameter, the response must also include the exact value from the request. The client will be using this to associate this response with the initial request.
  state: typed.string.maybe,
});
export interface OauthAuthorizeRequestDone {
  status: 'ok';
  // Authorization completed, now access token can be obtained.
  answer: typed.Get<typeof oauthAuthorizeRequestOk>;
}
// Authorization request
export const oauthAuthorizeRequestFx = createEffect<
  OauthAuthorizeRequest,
  OauthAuthorizeRequestDone,
  OauthAuthorizeRequestFail
>({
  async handler() {
    const name = 'oauthAuthorizeRequest.body';
    const answer = await requestFx({
      path: '/oauth/authorize',
      method: 'POST',
    });
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, oauthAuthorizeRequestOk, answer.body),
        };
      case 400:
        throwWith(
          name,
          oauthAuthorizeRequestBadRequest,
          'bad_request',
          answer.body,
        );
      case 500:
        throwWith(
          name,
          oauthAuthorizeRequestInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion oauthAuthorizeRequest

//#region oauthToken
const oauthTokenCreated = typed.object({
  access_token: typed.string,
  token_type: typed.union('bearer'),
  // UTC Unix TimeStamp when the access token expires
  expires_in: custom.any.maybe,
});
export interface OauthTokenDone {
  status: 'created';
  // The auth services validated the request and responds with an access token [OAuth2 Example Flow](https://www.oauth.com/oauth2-servers/server-side-apps/example-flow/)
  answer: typed.Get<typeof oauthTokenCreated>;
}
// Exchange the authorization code for an access token
export const oauthTokenFx = createEffect<
  OauthToken,
  OauthTokenDone,
  OauthTokenFail
>({
  async handler() {
    const name = 'oauthToken.body';
    const answer = await requestFx({
      path: '/oauth/token',
      method: 'POST',
    });
    switch (answer.status) {
      case 201:
        return {
          status: 'created',
          answer: parseWith(name, oauthTokenCreated, answer.body),
        };
      case 400:
        throwWith(name, oauthTokenBadRequest, 'bad_request', answer.body);
      case 500:
        throwWith(
          name,
          oauthTokenInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion oauthToken

//#region accessRecoverySendEmail
const accessRecoverySendEmailOk = typed.undef;
export interface AccessRecoverySendEmailDone {
  status: 'ok';
  // Password changed successfully
  answer: typed.Get<typeof accessRecoverySendEmailOk>;
}
// Send password recovery confirmation code to email
export const accessRecoverySendEmailFx = createEffect<
  AccessRecoverySendEmail,
  AccessRecoverySendEmailDone,
  AccessRecoverySendEmailFail
>({
  async handler() {
    const name = 'accessRecoverySendEmail.body';
    const answer = await requestFx({
      path: '/access-recovery/send-email',
      method: 'POST',
    });
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, accessRecoverySendEmailOk, answer.body),
        };
      case 400:
        throwWith(
          name,
          accessRecoverySendEmailBadRequest,
          'bad_request',
          answer.body,
        );
      case 500:
        throwWith(
          name,
          accessRecoverySendEmailInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion accessRecoverySendEmail

//#region accessRecoverySetPassword
const accessRecoverySetPasswordOk = typed.undef;
export interface AccessRecoverySetPasswordDone {
  status: 'ok';
  // Confirmation code is sent to email
  answer: typed.Get<typeof accessRecoverySetPasswordOk>;
}
// Set new password by reset code from email
export const accessRecoverySetPasswordFx = createEffect<
  AccessRecoverySetPassword,
  AccessRecoverySetPasswordDone,
  AccessRecoverySetPasswordFail
>({
  async handler() {
    const name = 'accessRecoverySetPassword.body';
    const answer = await requestFx({
      path: '/access-recovery/set-password',
      method: 'POST',
    });
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, accessRecoverySetPasswordOk, answer.body),
        };
      case 400:
        throwWith(
          name,
          accessRecoverySetPasswordBadRequest,
          'bad_request',
          answer.body,
        );
      case 500:
        throwWith(
          name,
          accessRecoverySetPasswordInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion accessRecoverySetPassword

//#region viewerGet
const viewerGetOk = typed.object({
  firstName: typed.string,
  lastName: typed.string,
  id: typed.string,
});
export interface ViewerGetDone {
  status: 'ok';
  // Get profile of the user
  answer: typed.Get<typeof viewerGetOk>;
}
// Get info about viewer by access token
export const viewerGetFx = createEffect<
  ViewerGet,
  ViewerGetDone,
  ViewerGetFail
>({
  async handler() {
    const name = 'viewerGet.body';
    const answer = await requestFx({
      path: '/viewer',
      method: 'GET',
    });
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, viewerGetOk, answer.body),
        };
      case 400:
        throwWith(name, viewerGetBadRequest, 'bad_request', answer.body);
      case 500:
        throwWith(
          name,
          viewerGetInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion viewerGet

//#region registerRequest
const registerRequestCreated = typed.object({
  // UTC Unix TimeStamp when the link expires
  expiresAt: custom.any,
});
export interface RegisterRequestDone {
  status: 'created';
  // Registration link sent to email, now user can find out when the link expires
  answer: typed.Get<typeof registerRequestCreated>;
}
// Send registration link to email
export const registerRequestFx = createEffect<
  RegisterRequest,
  RegisterRequestDone,
  RegisterRequestFail
>({
  async handler() {
    const name = 'registerRequest.body';
    const answer = await requestFx({
      path: '/register/request',
      method: 'POST',
    });
    switch (answer.status) {
      case 201:
        return {
          status: 'created',
          answer: parseWith(name, registerRequestCreated, answer.body),
        };
      case 400:
        throwWith(name, registerRequestBadRequest, 'bad_request', answer.body);
      case 500:
        throwWith(
          name,
          registerRequestInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion registerRequest

//#region registerConfirmation
const registerConfirmationCreated = typed.undef;
export interface RegisterConfirmationDone {
  status: 'created';
  // Okay, user created
  answer: typed.Get<typeof registerConfirmationCreated>;
}
// Confirm email, fill profile required fields and create user
export const registerConfirmationFx = createEffect<
  RegisterConfirmation,
  RegisterConfirmationDone,
  RegisterConfirmationFail
>({
  async handler() {
    const name = 'registerConfirmation.body';
    const answer = await requestFx({
      path: '/register/confirmation',
      method: 'POST',
    });
    switch (answer.status) {
      case 201:
        return {
          status: 'created',
          answer: parseWith(name, registerConfirmationCreated, answer.body),
        };
      case 400:
        throwWith(
          name,
          registerConfirmationBadRequest,
          'bad_request',
          answer.body,
        );
      case 500:
        throwWith(
          name,
          registerConfirmationInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion registerConfirmation

//#region sessionCreate
const sessionCreateCreated = typed.object({
  firstName: typed.string,
  lastName: typed.string,
});
export interface SessionCreateDone {
  status: 'created';
  // Session created, token wrote to cookies
  answer: typed.Get<typeof sessionCreateCreated>;
}
// Login and create new session token
export const sessionCreateFx = createEffect<
  SessionCreate,
  SessionCreateDone,
  SessionCreateFail
>({
  async handler() {
    const name = 'sessionCreate.body';
    const answer = await requestFx({
      path: '/session/create',
      method: 'POST',
    });
    switch (answer.status) {
      case 201:
        return {
          status: 'created',
          answer: parseWith(name, sessionCreateCreated, answer.body),
        };
      case 400:
        throwWith(name, sessionCreateBadRequest, 'bad_request', answer.body);
      case 500:
        throwWith(
          name,
          sessionCreateInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion sessionCreate

//#region sessionGet
const sessionGetOk = typed.object({
  // Current user in a session
  user: typed.object({
    firstName: typed.string,
    lastName: typed.string,
  }),
});
export interface SessionGetDone {
  status: 'ok';
  // Session exists
  answer: typed.Get<typeof sessionGetOk>;
}
// Read session token and show current session. Authenticated checked by session-token cookie
export const sessionGetFx = createEffect<
  SessionGet,
  SessionGetDone,
  SessionGetFail
>({
  async handler() {
    const name = 'sessionGet.body';
    const answer = await requestFx({
      path: '/session/get',
      method: 'POST',
    });
    switch (answer.status) {
      case 200:
        return {
          status: 'ok',
          answer: parseWith(name, sessionGetOk, answer.body),
        };
      case 401:
        throwWith(name, sessionGetUnauthorized, 'unauthorized', answer.body);
      case 500:
        throwWith(
          name,
          sessionGetInternalServerError,
          'internal_server_error',
          answer.body,
        );
      default:
        throw {
          status: 'unknown_status',
          error: { status: answer.status, body: answer.body },
        };
    }
  },
});
//#endregion sessionGet
